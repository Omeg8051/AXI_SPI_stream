module spi_front (
    input spi_clk_in,
    input rst_n,

    //spi interface
    output spi_clk_o,
    output spi_clk_t,
    output spi_mosi_o,
    output spi_mosi_t,
    input spi_miso_i,

    //data interface
    input [7:0] data_mosi,
    output [7:0] data_miso,

    //control interface
    input spi_begin,
    output spi_busy

);

/**
*8==================================================================================D
*8==================================================================================D
*8======================                                       =====================D
*8====================       AXIS READ STREAM OUTPUT DRIVE       ===================D
*8======================                                       =====================D
*8==================================================================================D
*8==================================================================================D
*/

localparam SPI_STATE_IDLE = 0;
localparam SPI_STATE_ARMED = 1;
localparam SPI_STATE_ACTIVE = 2;

reg [1:0] spi_state;
reg [2:0] spi_bit_ptr;
reg spi_clk_gate;
reg spi_busy_r;
reg [7:0]spi_tx_data;

assign spi_busy = spi_busy_r;
assign spi_clk_o = spi_clk_in & spi_clk_gate;


always @(negedge spi_clk_in or negedge rst_n) begin
    if(~rst_n) begin
        spi_state <= SPI_STATE_IDLE;
        spi_bit_ptr <= 3'b0;
        spi_clk_gate <= 1'b0;
        spi_busy_r <= 1'b0;
        spi_tx_data <= 8'b0;
    end else begin
        case (spi_state)
            SPI_STATE_IDLE:begin
                if(spi_begin)begin
                    /*
                    spi_state <= SPI_STATE_ARMED;
                    spi_bit_ptr <= 3'b0;
                    spi_clk_gate <= 1'b0;
                    spi_busy_r <= 1'b1;
                    */
                    spi_state <= SPI_STATE_ACTIVE;
                    spi_bit_ptr <= 3'h7;
                    spi_clk_gate <= 1'b1;
                    spi_busy_r <= 1'b1;
                    spi_tx_data <= data_mosi;
                end
            end
            SPI_STATE_ARMED:begin
                if(spi_busy_r)begin
                    spi_state <= SPI_STATE_ACTIVE;
                    spi_bit_ptr <= 3'h7;
                    spi_clk_gate <= 1'b1;
                    spi_busy_r <= 1'b1;
                end
            end 
            SPI_STATE_ACTIVE:begin
                if(~|spi_bit_ptr)begin
                    spi_state <= SPI_STATE_IDLE;
                    spi_bit_ptr <= 3'h0;
                    spi_clk_gate <= 1'b0;
                    spi_busy_r <= 1'b0;
                end else begin
                    spi_bit_ptr <= spi_bit_ptr - 3'b1;
                    
                end
            end
            default: begin
                spi_state <= SPI_STATE_IDLE;
                spi_bit_ptr <= 3'b0;
                spi_clk_gate <= 1'b0;
                spi_busy_r <= 1'b0; 
            end

        endcase
    end
end

assign spi_mosi_o = (spi_bit_ptr == 3'h0)? spi_tx_data[7] :
                    (spi_bit_ptr == 3'h1)? spi_tx_data[6] :
                    (spi_bit_ptr == 3'h2)? spi_tx_data[5] :
                    (spi_bit_ptr == 3'h3)? spi_tx_data[4] :
                    (spi_bit_ptr == 3'h4)? spi_tx_data[3] :
                    (spi_bit_ptr == 3'h5)? spi_tx_data[2] :
                    (spi_bit_ptr == 3'h6)? spi_tx_data[1] :spi_tx_data[0];


reg [7:0]spi_rx_data;
assign data_miso = spi_rx_data;
always @(posedge spi_clk_in or negedge rst_n) begin
    if(~rst_n) begin
        spi_rx_data <= 8'b0;
    end else if(spi_busy_r) begin
        spi_rx_data <= {spi_rx_data[6:0],spi_miso_i};
    end else begin
        spi_rx_data <= spi_rx_data;
    end
end


endmodule